<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PKG/HDM Research Explorer - Personal Research Tool</title>
    <link rel="stylesheet" href="css/styles.css">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        /* Navigation Styles */
        .nav-header {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            padding: 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-bottom: 0;
            width: 100%;
        }
        
        .nav-container {
            max-width: 100%;
            margin: 0;
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .nav-title {
            color: white;
            font-size: 16px;
            font-weight: 500;
            margin: 0;
        }
        
        .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .nav-link {
            color: white;
            text-decoration: none;
            padding: 8px 16px;
            border-radius: 20px;
            transition: all 0.3s ease;
            font-size: 14px;
            border: 1px solid rgba(255,255,255,0.3);
        }
        
        .nav-link:hover {
            background: rgba(255,255,255,0.2);
            transform: translateY(-1px);
        }
        
        .nav-link.active {
            background: rgba(255,255,255,0.3);
            font-weight: 500;
        }
        
        @media (max-width: 768px) {
            .nav-container {
                flex-direction: column;
                gap: 10px;
            }
            
            .nav-links {
                justify-content: center;
            }
        }
        
        /* Make visualization container scrollable */
        #visualization-container {
            height: 70vh;
            overflow-y: auto;
            overflow-x: hidden;
        }
        
        .view {
            min-height: 100%;
        }
        
        /* Opportunities Dashboard Styles */
        #opportunities-dashboard {
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            margin: 20px;
            max-height: none;
            overflow-y: visible;
        }
        
        .dashboard-header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .dashboard-header h3 {
            color: #2c3e50;
            margin-bottom: 10px;
        }
        
        .dashboard-header p {
            color: #7f8c8d;
            font-size: 14px;
        }
        
        .opportunity-stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        
        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            text-align: center;
            min-width: 120px;
            margin: 5px;
        }
        
        .stat-number {
            font-size: 24px;
            font-weight: bold;
            color: #e74c3c;
            margin-bottom: 5px;
        }
        
        .stat-label {
            font-size: 12px;
            color: #7f8c8d;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .opportunity-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
        
        .opportunity-section {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .opportunity-section h4 {
            margin-bottom: 15px;
            color: #2c3e50;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 10px;
        }
        
        .opportunity-item {
            background: #f8f9fa;
            padding: 12px;
            margin-bottom: 10px;
            border-radius: 6px;
            border-left: 4px solid #3498db;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .opportunity-item:hover {
            background: #e8f4f8;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        .opportunity-item h5 {
            margin: 0 0 5px 0;
            color: #2c3e50;
            font-size: 14px;
        }
        
        .opportunity-item p {
            margin: 0;
            font-size: 12px;
            color: #7f8c8d;
        }
        
        .opportunity-tags {
            margin-top: 8px;
        }
        
        .opportunity-tag {
            background: #3498db;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            margin-right: 4px;
        }
        
        /* University Ready Analysis Styles */
        #university-ready-analysis {
            background: #f8f9fa;
            border: 2px solid #3498db;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        
        #university-ready-analysis h4 {
            color: #2c3e50;
            margin-bottom: 12px;
            border-bottom: 2px solid #3498db;
            padding-bottom: 8px;
        }
        
        .score-container {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
        }
        
        .score-item {
            text-align: center;
            flex: 1;
            margin: 0 5px;
        }
        
        .score-value {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .score-value.high {
            color: #27ae60;
        }
        
        .score-value.medium {
            color: #f39c12;
        }
        
        .score-value.low {
            color: #e74c3c;
        }
        
        .score-label {
            font-size: 11px;
            color: #7f8c8d;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .criteria-list {
            margin-top: 15px;
        }
        
        .criteria-item {
            background: white;
            padding: 8px;
            margin-bottom: 8px;
            border-radius: 4px;
            border-left: 3px solid #3498db;
            font-size: 12px;
        }
        
        .criteria-item.met {
            border-left-color: #27ae60;
            background: #d5f4e6;
        }
        
        .criteria-item.not-met {
            border-left-color: #e74c3c;
            background: #fadbd8;
        }
        
        .readiness-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 10px;
        }
        
        .readiness-badge.ready {
            background: #27ae60;
            color: white;
        }
        
        .readiness-badge.not-ready {
            background: #e74c3c;
            color: white;
        }
        
        .readiness-badge.potential {
            background: #f39c12;
            color: white;
        }
    </style>
</head>
<body>
    <!-- Unified Navigation and Header -->
    <nav class="nav-header">
        <div class="nav-container">
            <h2 class="nav-title">üîç PKG Research Explorer</h2>
            <div class="nav-links">
                <a href="../../index.html" class="nav-link">üè† Home</a>
                <a href="../../literature_review.html" class="nav-link">üìä Literature Review</a>
                <a href="../index.html" class="nav-link">üï∏Ô∏è Knowledge Graph</a>
                <a href="index.html" class="nav-link active">üîç PKG Explorer</a>
                <a href="../all-papers.html" class="nav-link">üìö All Papers</a>
                <a href="https://github.com/epireve/hdm" class="nav-link" target="_blank">üì± GitHub</a>
            </div>
        </div>
    </nav>

    <div id="header">
        <h4>Human Digital Memory - PKG Research Explorer</h4>
        <div id="stats">
            <span class="stat-item">
                <span class="stat-label">Concepts:</span>
                <span id="concept-count" class="stat-value">0</span>
            </span>
            <span class="stat-item">
                <span class="stat-label">Papers:</span>
                <span id="paper-count" class="stat-value">0</span>
            </span>
            <span class="stat-item">
                <span class="stat-label">Categories:</span>
                <span id="category-count" class="stat-value">0</span>
            </span>
            <span class="stat-item">
                <span class="stat-label">Research Gaps:</span>
                <span id="gap-count" class="stat-value">926</span>
            </span>
        </div>
    </div>
    
    <div id="app">

        <!-- Control Panel -->
        <div id="controls">
            <div class="control-group">
                <label>View Mode:</label>
                <select id="viewMode">
                    <option value="network">Network Graph</option>
                    <option value="hierarchy">Hierarchical Tree</option>
                    <option value="matrix">Co-occurrence Matrix</option>
                    <option value="opportunities">Research Opportunities</option>
                </select>
            </div>
            <div class="control-group">
                <label>Filter by Category:</label>
                <select id="categoryFilter">
                    <option value="all">All Categories</option>
                </select>
            </div>
            <div class="control-group">
                <label>Filter by Domain:</label>
                <select id="domainFilter">
                    <option value="all">All Domains</option>
                    <option value="education">Education (1842)</option>
                    <option value="healthcare">Healthcare (1572)</option>
                    <option value="social">Social (1473)</option>
                    <option value="iot">IoT (996)</option>
                    <option value="enterprise">Enterprise (906)</option>
                    <option value="general">General (1725)</option>
                </select>
            </div>
            <div class="control-group">
                <label>Min Frequency:</label>
                <input type="range" id="frequencySlider" min="2" max="50" value="2">
                <span id="frequencyValue">2</span>
            </div>
            <div class="control-group">
                <button id="resetView">Reset View</button>
                <button id="exportData">Export Selection</button>
            </div>
        </div>

        <!-- Main Content Area -->
        <div id="main-content">
            <!-- Main Visualization Area -->
            <div id="visualization-container">
                <div id="network-view" class="view active">
                    <svg id="network-svg"></svg>
                </div>
                <div id="hierarchy-view" class="view">
                    <svg id="hierarchy-svg"></svg>
                </div>
                <div id="matrix-view" class="view">
                    <svg id="matrix-svg"></svg>
                </div>
                <div id="opportunities-view" class="view">
                    <div id="opportunities-dashboard">
                        <div class="dashboard-header">
                            <h3>Research Opportunity Intelligence</h3>
                            <p>Discover unexplored concept intersections and cross-domain opportunities</p>
                        </div>
                        <div class="opportunity-stats">
                            <div class="stat-card">
                                <div class="stat-number">926</div>
                                <div class="stat-label">Concept Intersections</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-number">52</div>
                                <div class="stat-label">Cross-Domain Opportunities</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-number">26</div>
                                <div class="stat-label">University Ready</div>
                            </div>
                        </div>
                        <div class="opportunity-grid">
                            <div class="opportunity-section">
                                <h4>üî• High Opportunity Concepts</h4>
                                <div id="high-opportunity-list"></div>
                            </div>
                            <div class="opportunity-section">
                                <h4>üåü Emerging Concepts</h4>
                                <div id="emerging-concepts-list"></div>
                            </div>
                            <div class="opportunity-section">
                                <h4>üîÑ Cross-Domain Potential</h4>
                                <div id="cross-domain-list"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Side Panel -->
            <div id="side-panel">
                <!-- Detail Panel -->
                <div id="detail-panel">
                    <h3>Concept Details</h3>
                    <div id="concept-info">
                        <p>Click on a concept to see details</p>
                    </div>
                    <div id="related-concepts">
                        <h4>Related Concepts</h4>
                        <ul id="related-list"></ul>
                    </div>
                    <div id="concept-insights">
                        <h4>Research Insights</h4>
                        <div id="insights-content"></div>
                    </div>
                    <div id="university-ready-analysis" style="display: none;">
                        <h4>üéì University Ready Analysis</h4>
                        <div id="university-analysis-content"></div>
                    </div>
                    <div id="related-papers">
                        <h4>Related Papers</h4>
                        <div id="papers-list"></div>
                    </div>
                    <div id="concept-actions">
                        <button id="add-to-notes">Add to Research Notes</button>
                        <button id="copy-details">Copy Details</button>
                    </div>
                </div>

                <!-- Research Notes Section -->
                <div id="research-notes">
                    <h3>Research Notes</h3>
                    <textarea id="notes-input" placeholder="Add your research notes here..."></textarea>
                    <button id="save-notes">Save Notes</button>
                    <div id="saved-notes"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Paper Viewer Modal -->
    <div id="paper-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="paper-title">Paper Title</h2>
                <span class="close">&times;</span>
            </div>
            <div class="modal-body">
                <div id="paper-metadata"></div>
                <div id="paper-content"></div>
            </div>
        </div>
    </div>

    <script>
    // Global variables
    let data = null;
    let currentView = 'network';
    let selectedNodes = new Set();
    let notes = JSON.parse(localStorage.getItem('researchNotes') || '{}');

    // Load visualization data
    d3.json('data/visualization_data.json').then(function(loadedData) {
        data = loadedData;
        updateStats();
        initializeControls();
        renderVisualization();
    });

    // Update statistics in header
    function updateStats() {
        if (!data) return;
        
        // Update concept count
        const conceptCount = data.network.nodes.length;
        document.getElementById('concept-count').textContent = conceptCount;
        
        // Update paper count (count unique papers from sample_papers)
        const uniquePapers = new Set();
        data.network.nodes.forEach(node => {
            if (node.sample_papers) {
                node.sample_papers.forEach(paper => {
                    uniquePapers.add(paper.id);
                });
            }
        });
        document.getElementById('paper-count').textContent = uniquePapers.size;
        
        // Update category count
        const categoryCount = data.filters.categories.length;
        document.getElementById('category-count').textContent = categoryCount;
    }

    // Initialize controls
    function initializeControls() {
        // Populate category filter
        const categoryFilter = document.getElementById('categoryFilter');
        data.filters.categories.forEach(category => {
            const option = document.createElement('option');
            option.value = category;
            option.textContent = category.replace('_', ' ').charAt(0).toUpperCase() + category.slice(1);
            categoryFilter.appendChild(option);
        });

        // Event listeners
        document.getElementById('viewMode').addEventListener('change', function(e) {
            currentView = e.target.value;
            switchView();
        });

        document.getElementById('categoryFilter').addEventListener('change', renderVisualization);
        document.getElementById('domainFilter').addEventListener('change', renderVisualization);
        
        document.getElementById('frequencySlider').addEventListener('input', function(e) {
            document.getElementById('frequencyValue').textContent = e.target.value;
            renderVisualization();
        });

        document.getElementById('resetView').addEventListener('click', resetView);
        document.getElementById('exportData').addEventListener('click', exportData);
        document.getElementById('save-notes').addEventListener('click', saveNotes);
        
        // New action buttons
        document.getElementById('add-to-notes').addEventListener('click', addConceptToNotes);
        document.getElementById('copy-details').addEventListener('click', copyConceptDetails);
    }

    // Switch between views
    function switchView() {
        document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
        document.getElementById(currentView + '-view').classList.add('active');
        renderVisualization();
    }

    // Main rendering function
    function renderVisualization() {
        switch(currentView) {
            case 'network':
                renderNetworkGraph();
                break;
            case 'hierarchy':
                renderHierarchyTree();
                break;
            case 'matrix':
                renderCooccurrenceMatrix();
                break;
            case 'opportunities':
                renderOpportunitiesDashboard();
                break;
        }
    }

    // Network Graph Visualization
    function renderNetworkGraph() {
        const svg = d3.select('#network-svg');
        svg.selectAll('*').remove();

        const width = svg.node().getBoundingClientRect().width;
        const height = 600;
        svg.attr('width', width).attr('height', height);

        // Filter data based on controls
        const minFreq = parseInt(document.getElementById('frequencySlider').value);
        const category = document.getElementById('categoryFilter').value;
        const domain = document.getElementById('domainFilter').value;
        
        const filteredNodes = data.network.nodes.filter(n => 
            n.frequency >= minFreq && 
            (category === 'all' || n.category === category) &&
            (domain === 'all' || (n.domains && n.domains.includes(domain)))
        );
        
        const nodeIds = new Set(filteredNodes.map(n => n.id));
        const filteredEdges = data.network.edges.filter(e => 
            nodeIds.has(e.source) && nodeIds.has(e.target)
        );

        // Create force simulation
        const simulation = d3.forceSimulation(filteredNodes)
            .force('link', d3.forceLink(filteredEdges).id(d => d.id).distance(100))
            .force('charge', d3.forceManyBody().strength(-300))
            .force('center', d3.forceCenter(width / 2, height / 2))
            .force('collision', d3.forceCollide().radius(d => d.size + 5));

        // Create container
        const g = svg.append('g');

        // Add zoom behavior
        const zoom = d3.zoom()
            .scaleExtent([0.1, 4])
            .on('zoom', (event) => g.attr('transform', event.transform));
        
        svg.call(zoom);

        // Draw edges
        const link = g.selectAll('.link')
            .data(filteredEdges)
            .enter().append('line')
            .attr('class', 'link')
            .style('stroke', '#999')
            .style('stroke-opacity', 0.6)
            .style('stroke-width', d => Math.sqrt(d.weight));

        // Draw nodes
        const node = g.selectAll('.node')
            .data(filteredNodes)
            .enter().append('g')
            .attr('class', 'node')
            .call(d3.drag()
                .on('start', dragstarted)
                .on('drag', dragged)
                .on('end', dragended));

        // Node circles
        node.append('circle')
            .attr('r', d => d.size / 2)
            .style('fill', d => getCategoryColor(d.category))
            .style('stroke', d => {
                // Add special stroke for high opportunity concepts
                if (data.gap_analysis && data.gap_analysis.high_opportunity_indicators.includes(d.name.toLowerCase())) {
                    return '#e74c3c'; // Red for high opportunity
                } else if (d.frequency < 5) {
                    return '#3498db'; // Blue for emerging concepts
                } else {
                    return '#fff'; // Default white
                }
            })
            .style('stroke-width', d => {
                // Thicker stroke for opportunity concepts
                if (data.gap_analysis && data.gap_analysis.high_opportunity_indicators.includes(d.name.toLowerCase())) {
                    return 4; // Thick for high opportunity
                } else if (d.frequency < 5) {
                    return 3; // Medium for emerging
                } else {
                    return 2; // Default
                }
            })
            .on('click', (event, d) => selectNode(d))
            .on('mouseover', (event, d) => showTooltip(event, d))
            .on('mouseout', hideTooltip);

        // Node labels
        node.append('text')
            .text(d => d.name)
            .style('font-size', d => Math.min(d.size / 3, 12) + 'px')
            .attr('dx', d => d.size / 2 + 5)
            .attr('dy', 3);

        // Update positions on simulation tick
        simulation.on('tick', () => {
            link
                .attr('x1', d => d.source.x)
                .attr('y1', d => d.source.y)
                .attr('x2', d => d.target.x)
                .attr('y2', d => d.target.y);

            node.attr('transform', d => `translate(${d.x},${d.y})`);
        });

        // Drag functions
        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }
    }

    // Hierarchy Tree Visualization
    function renderHierarchyTree() {
        const svg = d3.select('#hierarchy-svg');
        svg.selectAll('*').remove();

        const width = svg.node().getBoundingClientRect().width;
        const height = 800;
        const margin = {top: 20, right: 90, bottom: 30, left: 90};

        svg.attr('width', width).attr('height', height);

        const g = svg.append('g')
            .attr('transform', `translate(${margin.left},${margin.top})`);

        // Create tree layout
        const treeLayout = d3.tree()
            .size([height - margin.top - margin.bottom, width - margin.left - margin.right]);

        // Create hierarchy
        const root = d3.hierarchy(data.hierarchy);
        treeLayout(root);

        // Draw links
        g.selectAll('.link')
            .data(root.links())
            .enter().append('path')
            .attr('class', 'link')
            .attr('d', d3.linkHorizontal()
                .x(d => d.y)
                .y(d => d.x))
            .style('fill', 'none')
            .style('stroke', '#ccc')
            .style('stroke-width', 2);

        // Draw nodes
        const node = g.selectAll('.node')
            .data(root.descendants())
            .enter().append('g')
            .attr('class', 'node')
            .attr('transform', d => `translate(${d.y},${d.x})`);

        node.append('circle')
            .attr('r', d => d.children ? 5 : 10)
            .style('fill', d => d.children ? '#555' : getCategoryColor(d.data.category))
            .on('click', (event, d) => {
                if (d.data.id !== undefined) {
                    selectNode(data.network.nodes.find(n => n.id === d.data.id));
                }
            });

        node.append('text')
            .attr('dy', 3)
            .attr('x', d => d.children ? -10 : 10)
            .style('text-anchor', d => d.children ? 'end' : 'start')
            .text(d => d.data.name)
            .style('font-size', '12px');
    }

    // Co-occurrence Matrix Visualization
    function renderCooccurrenceMatrix() {
        const svg = d3.select('#matrix-svg');
        svg.selectAll('*').remove();

        const width = 800;
        const height = 800;
        const margin = {top: 100, right: 10, bottom: 10, left: 100};

        svg.attr('width', width).attr('height', height);

        // Get top N concepts for matrix
        const topConcepts = data.network.nodes
            .sort((a, b) => b.frequency - a.frequency)
            .slice(0, 20);

        const conceptIds = topConcepts.map(c => c.id);
        const size = topConcepts.length;
        const cellSize = (width - margin.left - margin.right) / size;

        // Create matrix data
        const matrix = [];
        for (let i = 0; i < size; i++) {
            for (let j = 0; j < size; j++) {
                const edge = data.network.edges.find(e => 
                    (e.source === conceptIds[i] && e.target === conceptIds[j]) ||
                    (e.source === conceptIds[j] && e.target === conceptIds[i])
                );
                matrix.push({
                    x: j,
                    y: i,
                    value: edge ? edge.weight : (i === j ? topConcepts[i].frequency : 0)
                });
            }
        }

        const g = svg.append('g')
            .attr('transform', `translate(${margin.left},${margin.top})`);

        // Color scale
        const colorScale = d3.scaleSequential(d3.interpolateBlues)
            .domain([0, d3.max(matrix, d => d.value)]);

        // Draw cells
        g.selectAll('.cell')
            .data(matrix)
            .enter().append('rect')
            .attr('class', 'cell')
            .attr('x', d => d.x * cellSize)
            .attr('y', d => d.y * cellSize)
            .attr('width', cellSize - 2)
            .attr('height', cellSize - 2)
            .style('fill', d => d.value > 0 ? colorScale(d.value) : '#f0f0f0')
            .style('stroke', '#fff')
            .on('mouseover', (event, d) => {
                if (d.value > 0) {
                    showMatrixTooltip(event, d, topConcepts[d.y].name, topConcepts[d.x].name);
                }
            })
            .on('mouseout', hideTooltip);

        // Add labels
        g.selectAll('.row-label')
            .data(topConcepts)
            .enter().append('text')
            .attr('class', 'row-label')
            .attr('x', -5)
            .attr('y', (d, i) => i * cellSize + cellSize / 2)
            .attr('dy', 3)
            .style('text-anchor', 'end')
            .style('font-size', '10px')
            .text(d => d.name);

        g.selectAll('.col-label')
            .data(topConcepts)
            .enter().append('text')
            .attr('class', 'col-label')
            .attr('x', (d, i) => i * cellSize + cellSize / 2)
            .attr('y', -5)
            .attr('transform', (d, i) => `rotate(-45,${i * cellSize + cellSize / 2},-5)`)
            .style('text-anchor', 'start')
            .style('font-size', '10px')
            .text(d => d.name);
    }

    // Research Opportunities Dashboard
    function renderOpportunitiesDashboard() {
        if (!data || !data.gap_analysis) return;
        
        // Render high opportunity concepts
        const highOpportunityList = document.getElementById('high-opportunity-list');
        const highOpportunityNodes = data.network.nodes.filter(node => 
            data.gap_analysis.high_opportunity_indicators.includes(node.name.toLowerCase())
        );
        
        highOpportunityList.innerHTML = highOpportunityNodes.map(node => `
            <div class="opportunity-item" onclick="selectNodeAndShowAnalysis(${JSON.stringify(node).replace(/"/g, '&quot;')})">
                <h5>${node.name} (${node.frequency} papers)</h5>
                <p>High collaboration potential for university partnerships</p>
                <div class="opportunity-tags">
                    ${node.domains ? node.domains.map(domain => 
                        `<span class="opportunity-tag">${domain}</span>`
                    ).join('') : ''}
                </div>
            </div>
        `).join('');
        
        // Render emerging concepts
        const emergingList = document.getElementById('emerging-concepts-list');
        const emergingNodes = data.network.nodes.filter(node => node.frequency < 5).slice(0, 10);
        
        emergingList.innerHTML = emergingNodes.map(node => `
            <div class="opportunity-item" onclick="selectNodeAndShowAnalysis(${JSON.stringify(node).replace(/"/g, '&quot;')})">
                <h5>${node.name} (${node.frequency} papers)</h5>
                <p>Emerging concept with high innovation potential</p>
                <div class="opportunity-tags">
                    ${node.domains ? node.domains.map(domain => 
                        `<span class="opportunity-tag">${domain}</span>`
                    ).join('') : ''}
                </div>
            </div>
        `).join('');
        
        // Render cross-domain concepts
        const crossDomainList = document.getElementById('cross-domain-list');
        const crossDomainNodes = data.network.nodes.filter(node => 
            node.domains && node.domains.length > 2
        ).slice(0, 10);
        
        crossDomainList.innerHTML = crossDomainNodes.map(node => `
            <div class="opportunity-item" onclick="selectNodeAndShowAnalysis(${JSON.stringify(node).replace(/"/g, '&quot;')})">
                <h5>${node.name} (${node.frequency} papers)</h5>
                <p>Cross-domain potential across ${node.domains.length} domains</p>
                <div class="opportunity-tags">
                    ${node.domains.map(domain => 
                        `<span class="opportunity-tag">${domain}</span>`
                    ).join('')}
                </div>
            </div>
        `).join('');
    }

    // Helper functions
    function getCategoryColor(category) {
        const colors = {
            'knowledge_graph': '#1f77b4',
            'hdm_specific': '#ff7f0e',
            'algorithms': '#2ca02c',
            'methodologies': '#d62728',
            'performance_metrics': '#9467bd',
            'architectures': '#8c564b',
            'frameworks_tools': '#e377c2',
            'data_integration': '#7f7f7f',
            'general': '#bcbd22',
            'temporal': '#17becf',
            'integration': '#aec7e8',
            'schema': '#ffbb78',
            'privacy': '#98df8a',
            'performance': '#ff9896'
        };
        return colors[category] || '#999';
    }

    function getDomainColor(domain) {
        const colors = {
            'education': '#3498db',
            'healthcare': '#e74c3c',
            'social': '#9b59b6',
            'iot': '#f39c12',
            'enterprise': '#2ecc71',
            'general': '#95a5a6'
        };
        return colors[domain] || '#7f8c8d';
    }

    function getGapIndicator(node) {
        // Simulate gap analysis based on concept intersection potential
        const highOpportunityNodes = ['pkg', 'heterogeneous data integration', 'temporal reasoning', 'privacy preserving'];
        const mediumOpportunityNodes = ['federated learning', 'knowledge fusion', 'semantic integration'];
        
        if (highOpportunityNodes.includes(node.name?.toLowerCase())) {
            return '<span style="color: #e74c3c; font-weight: bold;" title="High research opportunity potential">üî•</span>';
        } else if (mediumOpportunityNodes.includes(node.name?.toLowerCase())) {
            return '<span style="color: #f39c12; font-weight: bold;" title="Medium research opportunity">‚ö°</span>';
        } else if (node.frequency < 5) {
            return '<span style="color: #3498db; font-weight: bold;" title="Emerging concept">üåü</span>';
        }
        return '';
    }

    function selectNode(node) {
        // Update selection
        if (selectedNodes.has(node.id)) {
            selectedNodes.delete(node.id);
        } else {
            selectedNodes.add(node.id);
        }

        // Update detail panel
        updateDetailPanel(node);

        // Highlight in visualization
        d3.selectAll('.node circle')
            .style('stroke-width', d => selectedNodes.has(d.id) ? 4 : 2)
            .style('stroke', d => selectedNodes.has(d.id) ? '#000' : '#fff');
    }

    function updateDetailPanel(node) {
        const info = document.getElementById('concept-info');
        
        // Get domain information
        const domainBadges = node.domains ? node.domains.map(domain => 
            `<span class="domain-badge" style="background-color: ${getDomainColor(domain)}; color: white; padding: 2px 6px; border-radius: 3px; margin-right: 4px; font-size: 11px;">${domain}</span>`
        ).join('') : '';
        
        // Check for research gaps
        const gapIndicator = getGapIndicator(node);
        
        info.innerHTML = `
            <h4 style="color: ${getCategoryColor(node.category)}; margin-bottom: 10px;">${node.name} ${gapIndicator}</h4>
            <p><strong>Category:</strong> ${node.category.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}</p>
            <p><strong>Frequency:</strong> ${node.frequency} papers</p>
            <p><strong>Type:</strong> ${node.type}</p>
            <p><strong>Rank:</strong> #${node.id + 1} out of ${data.network.nodes.length} concepts</p>
            <p><strong>Domains:</strong> ${domainBadges || '<em>Not specified</em>'}</p>
        `;

        // Find related concepts
        const relatedList = document.getElementById('related-list');
        relatedList.innerHTML = '';
        
        const relatedEdges = data.network.edges.filter(e => 
            e.source === node.id || e.target === node.id
        );
        
        relatedEdges.forEach(edge => {
            const relatedId = edge.source === node.id ? edge.target : edge.source;
            const relatedNode = data.network.nodes.find(n => n.id === relatedId);
            if (relatedNode) {
                const li = document.createElement('li');
                li.innerHTML = `<strong>${relatedNode.name}</strong> 
                    <span style="color: #666;">(${relatedNode.category.replace(/_/g, ' ')}, 
                    strength: ${edge.weight})</span>`;
                li.style.cursor = 'pointer';
                li.onclick = () => selectNode(relatedNode);
                relatedList.appendChild(li);
            }
        });

        if (relatedEdges.length === 0) {
            relatedList.innerHTML = '<li style="color: #999;">No direct connections found</li>';
        }

        // Add research insights
        const insights = document.getElementById('insights-content');
        insights.innerHTML = generateInsights(node);

        // Show University Ready Analysis
        showUniversityReadyAnalysis(node);

        // Add related papers
        updateRelatedPapers(node);

        // Update current selected node for actions
        window.currentSelectedNode = node;
    }

    function generateInsights(node) {
        let insights = '<ul>';
        
        // Category-specific insights
        const categoryInsights = {
            'knowledge_graph': 'Core PKG concept - fundamental to personal knowledge management systems',
            'hdm_specific': 'Human Digital Memory specific - critical for HDM system implementation',
            'algorithms': 'Algorithm/technique - computational approach for PKG/HDM systems',
            'methodologies': 'Research methodology - approach or framework for PKG development',
            'performance_metrics': 'Performance measure - used to evaluate PKG/HDM system effectiveness',
            'architectures': 'System architecture - structural design pattern for PKG systems',
            'frameworks_tools': 'Implementation tool - practical framework or database for PKG',
            'data_integration': 'Data integration approach - method for combining heterogeneous data'
        };
        
        if (categoryInsights[node.category]) {
            insights += `<li><strong>Category Insight:</strong> ${categoryInsights[node.category]}</li>`;
        }
        
        // Domain-specific insights
        if (node.domains && node.domains.length > 0) {
            const domainInsights = {
                'education': 'Strong educational applications - personalised learning systems, adaptive curricula',
                'healthcare': 'Healthcare integration potential - patient records, clinical decision support',
                'social': 'Social network applications - community knowledge, collaborative platforms',
                'iot': 'IoT integration opportunities - sensor data fusion, smart environment systems',
                'enterprise': 'Enterprise applications - organizational knowledge management, business intelligence',
                'general': 'General purpose application across multiple domains'
            };
            
            const primaryDomain = node.domains[0];
            if (domainInsights[primaryDomain]) {
                insights += `<li><strong>Primary Domain (${primaryDomain}):</strong> ${domainInsights[primaryDomain]}</li>`;
            }
            
            if (node.domains.length > 1) {
                insights += `<li><strong>Cross-Domain Potential:</strong> Applicable across ${node.domains.length} domains - opportunities for interdisciplinary research</li>`;
            }
        }
        
        // Gap analysis insights
        const gapInsights = getGapAnalysisInsights(node);
        if (gapInsights.length > 0) {
            insights += `<li><strong>Research Opportunities:</strong> ${gapInsights.join(', ')}</li>`;
        }
        
        // Frequency-based insights
        if (node.frequency > 50) {
            insights += '<li><strong>High Frequency:</strong> This is a major concept in PKG research, appearing in 50+ papers</li>';
        } else if (node.frequency > 20) {
            insights += '<li><strong>Common Concept:</strong> Frequently discussed in PKG literature</li>';
        } else if (node.frequency < 5) {
            insights += '<li><strong>Emerging Concept:</strong> Relatively new or specialized area of research - high innovation potential</li>';
        }
        
        // Temporal concepts
        if (node.name.toLowerCase().includes('temporal')) {
            insights += '<li><strong>Temporal Focus:</strong> Related to time-based aspects of knowledge graphs, crucial for HDM systems</li>';
        }
        
        // Integration concepts
        if (node.name.toLowerCase().includes('integration') || node.name.toLowerCase().includes('heterogeneous')) {
            insights += '<li><strong>Integration Focus:</strong> Important for combining diverse data sources in PKG systems</li>';
        }
        
        // Privacy concepts
        if (node.name.toLowerCase().includes('privacy') || node.name.toLowerCase().includes('preserving')) {
            insights += '<li><strong>Privacy Focus:</strong> Critical for personal data protection in PKG/HDM systems</li>';
        }
        
        insights += '</ul>';
        return insights;
    }

    function getGapAnalysisInsights(node) {
        const insights = [];
        
        // Based on advanced_gap_analysis_report.json findings
        if (node.name?.toLowerCase().includes('pkg')) {
            insights.push('High collaboration potential for university partnerships');
        }
        
        if (node.name?.toLowerCase().includes('heterogeneous')) {
            insights.push('926 unexplored concept intersections identified');
        }
        
        if (node.frequency < 5) {
            insights.push('Emerging concept with modernization potential');
        }
        
        if (node.domains && node.domains.length > 3) {
            insights.push('Cross-domain transfer opportunities available');
        }
        
        return insights;
    }

    function showUniversityReadyAnalysis(node) {
        const analysisSection = document.getElementById('university-ready-analysis');
        const analysisContent = document.getElementById('university-analysis-content');
        
        // Calculate scores for this concept
        const scores = calculateUniversityReadinessScores(node);
        
        // Determine readiness level
        const isUniversityReady = scores.importance > 0.6 && scores.feasibility > 0.7;
        const hasPotential = scores.importance > 0.4 || scores.feasibility > 0.5;
        
        let readinessClass, readinessText;
        if (isUniversityReady) {
            readinessClass = 'ready';
            readinessText = 'University Ready';
        } else if (hasPotential) {
            readinessClass = 'potential';
            readinessText = 'Has Potential';
        } else {
            readinessClass = 'not-ready';
            readinessText = 'Not Ready';
        }
        
        analysisContent.innerHTML = `
            <div class="score-container">
                <div class="score-item">
                    <div class="score-value ${getScoreClass(scores.importance)}">${(scores.importance * 100).toFixed(0)}%</div>
                    <div class="score-label">Importance</div>
                </div>
                <div class="score-item">
                    <div class="score-value ${getScoreClass(scores.feasibility)}">${(scores.feasibility * 100).toFixed(0)}%</div>
                    <div class="score-label">Feasibility</div>
                </div>
                <div class="score-item">
                    <div class="score-value ${getScoreClass(scores.collaboration)}">${(scores.collaboration * 100).toFixed(0)}%</div>
                    <div class="score-label">Collaboration</div>
                </div>
            </div>
            
            <div class="criteria-list">
                <div class="criteria-item ${scores.importance > 0.6 ? 'met' : 'not-met'}">
                    <strong>High Importance (>60%):</strong> ${scores.importance > 0.6 ? '‚úì' : '‚úó'} 
                    Based on frequency (${node.frequency} papers) and research establishment
                </div>
                <div class="criteria-item ${scores.feasibility > 0.7 ? 'met' : 'not-met'}">
                    <strong>High Feasibility (>70%):</strong> ${scores.feasibility > 0.7 ? '‚úì' : '‚úó'} 
                    Technical achievability and resource requirements
                </div>
                <div class="criteria-item ${node.domains && node.domains.length > 1 ? 'met' : 'not-met'}">
                    <strong>Cross-Domain Potential:</strong> ${node.domains && node.domains.length > 1 ? '‚úì' : '‚úó'} 
                    ${node.domains ? `Applicable across ${node.domains.length} domains` : 'Single domain focus'}
                </div>
                <div class="criteria-item ${isHighOpportunity(node) ? 'met' : 'not-met'}">
                    <strong>Research Gap Identified:</strong> ${isHighOpportunity(node) ? '‚úì' : '‚úó'} 
                    ${isHighOpportunity(node) ? 'High collaboration potential identified' : 'No specific gaps identified'}
                </div>
            </div>
            
            <div class="readiness-badge ${readinessClass}">${readinessText}</div>
            
            <div style="margin-top: 15px; font-size: 12px; color: #7f8c8d;">
                <strong>University Collaboration Types:</strong><br>
                ${generateCollaborationSuggestions(node, scores)}
            </div>
        `;
        
        analysisSection.style.display = 'block';
    }
    
    function calculateUniversityReadinessScores(node) {
        // Importance score based on frequency and establishment
        const maxFrequency = Math.max(...data.network.nodes.map(n => n.frequency));
        const importanceScore = Math.min(1.0, node.frequency / maxFrequency + 0.2);
        
        // Feasibility score based on concept maturity and complexity
        let feasibilityScore = 0.5; // Base score
        
        // Higher feasibility for established categories
        if (['knowledge_graph', 'algorithms', 'methodologies'].includes(node.category)) {
            feasibilityScore += 0.2;
        }
        
        // Higher feasibility for moderate frequency (not too new, not too complex)
        if (node.frequency >= 5 && node.frequency <= 50) {
            feasibilityScore += 0.2;
        }
        
        // Bonus for cross-domain potential
        if (node.domains && node.domains.length > 2) {
            feasibilityScore += 0.1;
        }
        
        // Collaboration score based on domain diversity and research potential
        let collaborationScore = 0.4; // Base score
        
        if (node.domains && node.domains.length > 1) {
            collaborationScore += 0.3;
        }
        
        if (isHighOpportunity(node)) {
            collaborationScore += 0.3;
        }
        
        return {
            importance: Math.min(1.0, importanceScore),
            feasibility: Math.min(1.0, feasibilityScore),
            collaboration: Math.min(1.0, collaborationScore)
        };
    }
    
    function getScoreClass(score) {
        if (score >= 0.7) return 'high';
        if (score >= 0.5) return 'medium';
        return 'low';
    }
    
    function isHighOpportunity(node) {
        if (!data.gap_analysis) return false;
        return data.gap_analysis.high_opportunity_indicators.includes(node.name.toLowerCase());
    }
    
    function generateCollaborationSuggestions(node, scores) {
        const suggestions = [];
        
        if (scores.importance > 0.6 && scores.feasibility > 0.7) {
            suggestions.push('‚Ä¢ <strong>Joint Research Projects</strong> - Ready for immediate collaboration');
        }
        
        if (node.domains && node.domains.length > 2) {
            suggestions.push('‚Ä¢ <strong>Cross-Departmental Studies</strong> - Multi-domain applications');
        }
        
        if (node.frequency < 20) {
            suggestions.push('‚Ä¢ <strong>Graduate Student Projects</strong> - Emerging research area');
        }
        
        if (isHighOpportunity(node)) {
            suggestions.push('‚Ä¢ <strong>Grant Applications</strong> - High funding potential (NSF/NIH)');
        }
        
        if (node.category === 'data_integration' || node.category === 'hdm_specific') {
            suggestions.push('‚Ä¢ <strong>Industry Partnerships</strong> - Practical implementation opportunities');
        }
        
        return suggestions.length > 0 ? suggestions.join('<br>') : '‚Ä¢ Further analysis needed for collaboration potential';
    }

    function selectNodeAndShowAnalysis(node) {
        // Don't switch views - just show the analysis in the sidebar
        // Update the detail panel with node information
        updateDetailPanel(node);
        
        // Update current selected node for actions
        window.currentSelectedNode = node;
        
        // Scroll the side panel to show the university analysis
        setTimeout(() => {
            const analysisSection = document.getElementById('university-ready-analysis');
            if (analysisSection) {
                analysisSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }, 100);
    }

    function showTooltip(event, d) {
        const tooltip = d3.select('body').append('div')
            .attr('class', 'tooltip')
            .style('opacity', 0);

        tooltip.transition()
            .duration(200)
            .style('opacity', .9);
        
        tooltip.html(`<strong>${d.name}</strong><br/>
                     Category: ${d.category}<br/>
                     Frequency: ${d.frequency}`)
            .style('left', (event.pageX + 10) + 'px')
            .style('top', (event.pageY - 28) + 'px');
    }

    function showMatrixTooltip(event, d, row, col) {
        const tooltip = d3.select('body').append('div')
            .attr('class', 'tooltip')
            .style('opacity', 0);

        tooltip.transition()
            .duration(200)
            .style('opacity', .9);
        
        tooltip.html(`<strong>${row} ‚Üî ${col}</strong><br/>
                     Value: ${d.value}`)
            .style('left', (event.pageX + 10) + 'px')
            .style('top', (event.pageY - 28) + 'px');
    }

    function hideTooltip() {
        d3.selectAll('.tooltip').remove();
    }

    function resetView() {
        selectedNodes.clear();
        document.getElementById('categoryFilter').value = 'all';
        document.getElementById('domainFilter').value = 'all';
        document.getElementById('frequencySlider').value = 2;
        document.getElementById('frequencyValue').textContent = '2';
        renderVisualization();
    }

    function exportData() {
        const exportObj = {
            selectedConcepts: Array.from(selectedNodes).map(id => {
                const node = data.network.nodes.find(n => n.id === id);
                return {
                    name: node.name,
                    category: node.category,
                    frequency: node.frequency
                };
            }),
            notes: notes,
            timestamp: new Date().toISOString()
        };

        const dataStr = JSON.stringify(exportObj, null, 2);
        const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
        
        const exportFileDefaultName = `research_export_${new Date().toISOString().slice(0,10)}.json`;
        
        const linkElement = document.createElement('a');
        linkElement.setAttribute('href', dataUri);
        linkElement.setAttribute('download', exportFileDefaultName);
        linkElement.click();
    }

    function saveNotes() {
        const noteText = document.getElementById('notes-input').value;
        if (noteText.trim()) {
            const timestamp = new Date().toISOString();
            notes[timestamp] = noteText;
            localStorage.setItem('researchNotes', JSON.stringify(notes));
            
            // Display saved note
            const savedDiv = document.getElementById('saved-notes');
            const noteDiv = document.createElement('div');
            noteDiv.className = 'saved-note';
            noteDiv.innerHTML = `<small>${new Date(timestamp).toLocaleString()}</small><p>${noteText}</p>`;
            savedDiv.insertBefore(noteDiv, savedDiv.firstChild);
            
            // Clear input
            document.getElementById('notes-input').value = '';
        }
    }

    // Load saved notes on startup
    window.addEventListener('load', () => {
        const savedDiv = document.getElementById('saved-notes');
        Object.entries(notes).reverse().forEach(([timestamp, text]) => {
            const noteDiv = document.createElement('div');
            noteDiv.className = 'saved-note';
            noteDiv.innerHTML = `<small>${new Date(timestamp).toLocaleString()}</small><p>${text}</p>`;
            savedDiv.appendChild(noteDiv);
        });
    });

    // New action functions
    function addConceptToNotes() {
        if (!window.currentSelectedNode) return;
        
        const node = window.currentSelectedNode;
        const noteText = `
Concept: ${node.name}
Category: ${node.category.replace(/_/g, ' ')}
Frequency: ${node.frequency} papers
Insights: ${generateInsights(node).replace(/<[^>]*>/g, ' ').trim()}
        `.trim();
        
        document.getElementById('notes-input').value = noteText + '\n\n' + document.getElementById('notes-input').value;
        document.getElementById('notes-input').focus();
    }

    function copyConceptDetails() {
        if (!window.currentSelectedNode) return;
        
        const node = window.currentSelectedNode;
        const relatedConcepts = data.network.edges
            .filter(e => e.source === node.id || e.target === node.id)
            .map(e => {
                const relatedId = e.source === node.id ? e.target : e.source;
                const relatedNode = data.network.nodes.find(n => n.id === relatedId);
                return relatedNode ? relatedNode.name : '';
            })
            .filter(name => name)
            .join(', ');
        
        const details = `
${node.name}
================
Category: ${node.category.replace(/_/g, ' ')}
Frequency: ${node.frequency} papers
Type: ${node.type}
Related Concepts: ${relatedConcepts || 'None'}

Insights:
${generateInsights(node).replace(/<[^>]*>/g, ' ').trim()}
        `.trim();
        
        navigator.clipboard.writeText(details).then(() => {
            // Show feedback
            const btn = document.getElementById('copy-details');
            const originalText = btn.textContent;
            btn.textContent = 'Copied!';
            btn.style.backgroundColor = '#27ae60';
            setTimeout(() => {
                btn.textContent = originalText;
                btn.style.backgroundColor = '';
            }, 2000);
        });
    }

    // Paper-related functions
    function updateRelatedPapers(node) {
        const papersList = document.getElementById('papers-list');
        papersList.innerHTML = '';
        
        if (node.sample_papers && node.sample_papers.length > 0) {
            const ul = document.createElement('ul');
            ul.style.listStyle = 'none';
            ul.style.padding = '0';
            
            node.sample_papers.forEach(paper => {
                const li = document.createElement('li');
                li.style.marginBottom = '15px';
                li.style.padding = '12px';
                li.style.backgroundColor = '#f8f9fa';
                li.style.borderRadius = '4px';
                li.style.borderLeft = '3px solid #3498db';
                li.style.cursor = 'pointer';
                li.style.transition = 'background-color 0.2s';
                
                li.innerHTML = `
                    <div style="font-weight: 500; color: #2c3e50; margin-bottom: 5px;">${paper.title || 'Untitled'}</div>
                    <div style="font-size: 13px; color: #666;">
                        ${paper.authors || 'Authors not available'} (${paper.year || 'Year unknown'})
                    </div>
                    <div style="font-size: 11px; color: #999; margin-top: 4px;">
                        Click to view full paper ‚Ä¢ ID: ${paper.id || paper.cite_key || 'unknown'}
                    </div>
                `;
                
                li.onmouseover = () => li.style.backgroundColor = '#e9ecef';
                li.onmouseout = () => li.style.backgroundColor = '#f8f9fa';
                li.onclick = () => loadPaper(paper.id || paper.cite_key, paper);
                
                ul.appendChild(li);
            });
            
            papersList.appendChild(ul);
        } else {
            papersList.innerHTML = '<p style="color: #999; font-style: italic;">No sample papers available for this concept.</p>';
        }
    }

    function loadPaper(paperId, paperMetadata = null) {
        if (!paperId) {
            alert('Paper ID not available');
            return;
        }
        
        // Show modal
        const modal = document.getElementById('paper-modal');
        modal.style.display = 'block';
        
        // Set loading state
        document.getElementById('paper-title').textContent = 'Loading Paper...';
        document.getElementById('paper-metadata').innerHTML = '';
        document.getElementById('paper-content').innerHTML = '<div style="text-align: center; padding: 40px;"><div class="loading-spinner"></div><p style="color: #666; margin-top: 20px;">Loading paper content...</p></div>';
        
        // Try multiple possible paths for the paper
        const possiblePaths = [
            `../../markdown_papers/${paperId}/paper.md`,
            `../../markdown_papers/${paperId.toLowerCase()}/paper.md`,
            `../../papers/${paperId}/paper.md`,
            `../../papers/${paperId.toLowerCase()}/paper.md`,
            `/hdm/markdown_papers/${paperId}/paper.md`,
            `/hdm/markdown_papers/${paperId.toLowerCase()}/paper.md`,
            `/hdm/papers/${paperId}/paper.md`,
            `/hdm/papers/${paperId.toLowerCase()}/paper.md`
        ];
        
        console.log('Attempting to fetch paper:', paperId);
        
        // Try each path until one works
        tryFetchPaper(possiblePaths, 0)
            .then(response => {
                console.log('Paper fetch successful from:', response.url);
                return response.text();
            })
            .then(markdown => {
                // Parse frontmatter
                const frontmatterMatch = markdown.match(/^---\n([\s\S]*?)\n---/);
                let metadata = {};
                let content = markdown;
                
                if (frontmatterMatch) {
                    // Parse YAML frontmatter (enhanced parsing)
                    const yamlContent = frontmatterMatch[1];
                    const lines = yamlContent.split('\n');
                    
                    let currentKey = null;
                    lines.forEach(line => {
                        // Handle key-value pairs
                        const match = line.match(/^(\w+):\s*(.*)$/);
                        if (match) {
                            currentKey = match[1];
                            const value = match[2].trim();
                            
                            // Remove quotes if present
                            if ((value.startsWith('"') && value.endsWith('"')) || 
                                (value.startsWith("'") && value.endsWith("'"))) {
                                metadata[currentKey] = value.slice(1, -1);
                            } else {
                                metadata[currentKey] = value;
                            }
                        } else if (currentKey && line.trim().startsWith('- ')) {
                            // Handle list items
                            if (!Array.isArray(metadata[currentKey])) {
                                metadata[currentKey] = [];
                            }
                            metadata[currentKey].push(line.trim().substring(2));
                        }
                    });
                    
                    // Remove frontmatter from content
                    content = markdown.substring(frontmatterMatch[0].length);
                }
                
                // Update modal
                document.getElementById('paper-title').textContent = metadata.title || 'Untitled Paper';
                
                document.getElementById('paper-metadata').innerHTML = `
                    <div style="margin-bottom: 20px; padding: 15px; background-color: #f8f9fa; border-radius: 4px;">
                        <p><strong>Authors:</strong> ${metadata.authors || 'Not available'}</p>
                        <p><strong>Year:</strong> ${metadata.year || 'Not available'}</p>
                        <p><strong>DOI:</strong> ${metadata.doi ? `<a href="https://doi.org/${metadata.doi}" target="_blank">${metadata.doi}</a>` : 'Not available'}</p>
                        <p><strong>URL:</strong> ${metadata.url ? `<a href="${metadata.url}" target="_blank">View Original</a>` : 'Not available'}</p>
                    </div>
                `;
                
                // Convert markdown to HTML using marked library
                const htmlContent = convertMarkdownToHtml(content, paperId);
                document.getElementById('paper-content').innerHTML = htmlContent;
            })
            .catch(error => {
                document.getElementById('paper-title').textContent = paperMetadata?.title || 'Error Loading Paper';
                
                // Show metadata if available, even if markdown fails
                if (paperMetadata) {
                    document.getElementById('paper-metadata').innerHTML = `
                        <div style="margin-bottom: 20px; padding: 15px; background-color: #f8f9fa; border-radius: 4px;">
                            <p><strong>Authors:</strong> ${paperMetadata.authors || 'Not available'}</p>
                            <p><strong>Year:</strong> ${paperMetadata.year || 'Not available'}</p>
                            <p><strong>Paper ID:</strong> ${paperId}</p>
                        </div>
                    `;
                }
                
                document.getElementById('paper-content').innerHTML = `
                    <div style="padding: 20px; text-align: center;">
                        <p style="color: #e74c3c; font-weight: bold; margin-bottom: 15px;">‚ùå Failed to load paper: ${error.message}</p>
                        <p><strong>Paper ID:</strong> ${paperId}</p>
                        <div style="margin-top: 20px; padding: 15px; background-color: #f8f9fa; border-radius: 4px; text-align: left;">
                            <h4>üìã What we know about this paper:</h4>
                            ${paperMetadata ? `
                                <ul style="margin: 10px 0; color: #444;">
                                    <li><strong>Title:</strong> ${paperMetadata.title || 'Not available'}</li>
                                    <li><strong>Authors:</strong> ${paperMetadata.authors || 'Not available'}</li>
                                    <li><strong>Year:</strong> ${paperMetadata.year || 'Not available'}</li>
                                </ul>
                            ` : '<p style="color: #666;">No metadata available</p>'}
                            
                            <h4 style="margin-top: 20px;">üîß Troubleshooting:</h4>
                            <ul style="margin: 10px 0; color: #666;">
                                <li>Paper may not be available in markdown format</li>
                                <li>Check if the paper exists in the papers directory</li>
                                <li>Paper is referenced in concept analysis but not yet converted</li>
                            </ul>
                            <p style="margin-top: 15px; font-size: 14px; color: #666;">
                                <strong>Note:</strong> This paper is included in the research database but the full text may not be available for viewing yet.
                            </p>
                        </div>
                    </div>
                `;
            });
    }
    
    function tryFetchPaper(paths, index) {
        if (index >= paths.length) {
            return Promise.reject(new Error('Paper not found in any location'));
        }
        
        const currentPath = paths[index];
        console.log(`Trying path ${index + 1}/${paths.length}:`, currentPath);
        
        return fetch(currentPath)
            .then(response => {
                if (response.ok) {
                    response.url = currentPath; // Store the successful path
                    return response;
                }
                throw new Error(`HTTP ${response.status}`);
            })
            .catch(error => {
                console.log(`Path ${index + 1} failed:`, error.message);
                return tryFetchPaper(paths, index + 1);
            });
    }

    function convertMarkdownToHtml(markdown, paperId) {
        // Preprocess markdown to handle various citation formats
        console.log('Processing citations in markdown...');
        
        // Handle citation format [\[number\]]
        markdown = markdown.replace(/\[\\?\[(\d+)\\?\]\]/g, (match, num) => {
            console.log('Found citation:', match, '->', num);
            return `<sup><a href="#ref-${num}" style="color: #3498db; text-decoration: none;">[${num}]</a></sup>`;
        });
        
        // Handle standalone 'undefined' text that appears as citation placeholders
        // Only replace 'undefined' when it appears as a standalone word, not in compounds like "undefined-variable"
        markdown = markdown.replace(/\bundefined(?![-\w])/g, (match) => {
            console.log('Found undefined reference, replacing with [citation needed]');
            return '<span style="color: #e74c3c; font-style: italic;">[citation needed]</span>';
        });
        
        // Handle markdown links that might be citations
        markdown = markdown.replace(/\[(.*?)\]\(#page-(\d+)-(\d+)\)/g, (match, text, page, ref) => {
            console.log('Found page reference:', match);
            return `<sup><a href="#page-${page}-${ref}" style="color: #3498db; text-decoration: none;">[${text}]</a></sup>`;
        });
        
        // Create a new renderer instance
        const renderer = new marked.Renderer();
        
        // Override specific rendering methods
        renderer.image = function(href, title, text) {
            // Debug: log the original parameters
            console.log('Image renderer called with:', { href, title, text });
            
            // Handle case where href might be an object (marked.js compatibility issue)
            if (typeof href === 'object' && href !== null) {
                // If href is an object, try to extract the src property
                if (href.href) {
                    href = href.href;
                } else if (href.src) {
                    href = href.src;
                } else {
                    console.error('Image href is an object but no src/href property found:', href);
                    href = '';
                }
            }
            
            // Ensure href is a string
            href = String(href || '');
            console.log('Image href after processing:', href);
            
            // Check if it's a relative path
            if (href && !href.startsWith('http') && !href.startsWith('data:')) {
                // Adjust path based on environment (local vs GitHub Pages)
                const isGitHubPages = window.location.hostname.includes('github.io');
                const basePath = isGitHubPages ? '/hdm' : '';
                const newHref = `${basePath}/markdown_papers/${paperId}/${href}`;
                console.log('Image path transformation:', href, '->', newHref);
                href = newHref;
            }
            
            // Add responsive image styling with error handling and debugging
            return `<img src="${href}" alt="${text || ''}" title="${title || ''}" 
                    style="max-width: 100%; height: auto; display: block; margin: 20px auto;"
                    onload="console.log('Image loaded successfully: ${href}')"
                    onerror="console.error('Image failed to load: ${href}'); this.onerror=null; this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAwIiBoZWlnaHQ9IjMwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZjBmMGYwIi8+CiAgPHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSIxOCIgZmlsbD0iIzk5OSIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPkltYWdlIG5vdCBmb3VuZDwvdGV4dD4KPC9zdmc+'; this.alt='Image not found: ' + this.alt;">`;
        };
        
        renderer.table = function(header, body) {
            return `<div style="overflow-x: auto; margin: 20px 0;">
                <table style="border-collapse: collapse; width: 100%; min-width: 500px;">
                    <thead style="background-color: #f8f9fa;">${header}</thead>
                    <tbody>${body}</tbody>
                </table>
            </div>`;
        };
        
        renderer.tablerow = function(content) {
            return `<tr style="border-bottom: 1px solid #dee2e6;">${content}</tr>`;
        };
        
        renderer.tablecell = function(content, flags) {
            const type = flags.header ? 'th' : 'td';
            const align = flags.align ? `text-align: ${flags.align};` : '';
            const style = `padding: 12px; ${align} ${flags.header ? 'font-weight: bold;' : ''}`;
            return `<${type} style="${style}">${content}</${type}>`;
        };
        
        renderer.code = function(code, language) {
            return `<pre style="background-color: #f5f5f5; padding: 15px; border-radius: 4px; overflow-x: auto;"><code class="language-${language || 'text'}">${escapeHtml(code)}</code></pre>`;
        };
        
        renderer.link = function(href, title, text) {
            href = String(href || '');
            // Handle citation-style links that point to page anchors
            if (href.startsWith('#page-')) {
                return `<sup><a href="${href}" style="color: #3498db; text-decoration: none;">[${text}]</a></sup>`;
            }
            return `<a href="${href}" title="${title || ''}" target="_blank" style="color: #3498db;">${text}</a>`;
        };
        
        // Configure marked options with the custom renderer
        try {
            // Try the new API first (marked v4+)
            if (typeof marked.parse === 'function') {
                return marked.parse(markdown, {
                    renderer: renderer,
                    breaks: true,
                    gfm: true,
                    headerIds: true,
                    mangle: false,
                    pedantic: false,
                    sanitize: false,
                    smartLists: true,
                    smartypants: false
                });
            } else {
                // Fallback to old API
                marked.setOptions({
                    renderer: renderer,
                    breaks: true,
                    gfm: true,
                    headerIds: true,
                    mangle: false,
                    pedantic: false,
                    sanitize: false,
                    smartLists: true,
                    smartypants: false
                });
                return marked(markdown);
            }
        } catch (error) {
            console.error('Markdown parsing error:', error);
            // Fallback to basic rendering
            return `<pre>${escapeHtml(markdown)}</pre>`;
        }
    }
    
    function escapeHtml(text) {
        const map = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#039;'
        };
        return text.replace(/[&<>"']/g, m => map[m]);
    }

    // Modal close functionality
    document.addEventListener('DOMContentLoaded', function() {
        const modal = document.getElementById('paper-modal');
        const closeBtn = document.querySelector('.close');
        
        closeBtn.onclick = function() {
            modal.style.display = 'none';
        }
        
        window.onclick = function(event) {
            if (event.target == modal) {
                modal.style.display = 'none';
            }
        }
    });
    </script>
</body>
</html>