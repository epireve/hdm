<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PKG/HDM Research Explorer - Personal Research Tool</title>
    <link rel="stylesheet" href="css/styles.css">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        /* Navigation Styles */
        .nav-header {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            padding: 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-bottom: 0;
            width: 100%;
        }
        
        .nav-container {
            max-width: 100%;
            margin: 0;
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .nav-title {
            color: white;
            font-size: 16px;
            font-weight: 500;
            margin: 0;
        }
        
        .nav-links {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .nav-link {
            color: white;
            text-decoration: none;
            padding: 8px 16px;
            border-radius: 20px;
            transition: all 0.3s ease;
            font-size: 14px;
            border: 1px solid rgba(255,255,255,0.3);
        }
        
        .nav-link:hover {
            background: rgba(255,255,255,0.2);
            transform: translateY(-1px);
        }
        
        .nav-link.active {
            background: rgba(255,255,255,0.3);
            font-weight: 500;
        }
        
        @media (max-width: 768px) {
            .nav-container {
                flex-direction: column;
                gap: 10px;
            }
            
            .nav-links {
                justify-content: center;
            }
        }
        
        /* Header Styles */
        #header {
            background-color: #2c3e50;
            color: white;
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        #header h4 {
            margin: 0;
        }
        
        #stats {
            display: flex;
            gap: 2rem;
        }
        
        .stat-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .stat-label {
            font-size: 0.9rem;
            opacity: 0.8;
        }
        
        .stat-value {
            font-size: 1.2rem;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <!-- Unified Navigation and Header -->
    <nav class="nav-header">
        <div class="nav-container">
            <h2 class="nav-title">üîç PKG Research Explorer</h2>
            <div class="nav-links">
                <a href="../../index.html" class="nav-link">üè† Home</a>
                <a href="../../research_findings.html" class="nav-link">üìä Paper Browser</a>
                <a href="../index.html" class="nav-link">üï∏Ô∏è Knowledge Graph</a>
                <a href="index.html" class="nav-link active">üîç PKG Explorer</a>
                <a href="https://github.com/epireve/hdm" class="nav-link" target="_blank">üì± GitHub</a>
            </div>
        </div>
    </nav>

    <div id="header">
        <h4>Human Digital Memory - PKG Research Explorer</h4>
        <div id="stats">
            <span class="stat-item">
                <span class="stat-label">Concepts:</span>
                <span id="concept-count" class="stat-value">0</span>
            </span>
            <span class="stat-item">
                <span class="stat-label">Papers:</span>
                <span id="paper-count" class="stat-value">0</span>
            </span>
            <span class="stat-item">
                <span class="stat-label">Categories:</span>
                <span id="category-count" class="stat-value">0</span>
            </span>
        </div>
    </div>
    
    <div id="app">

        <!-- Control Panel -->
        <div id="controls">
            <div class="control-group">
                <label>View Mode:</label>
                <select id="viewMode">
                    <option value="network">Network Graph</option>
                    <option value="hierarchy">Hierarchical Tree</option>
                    <option value="matrix">Co-occurrence Matrix</option>
                </select>
            </div>
            <div class="control-group">
                <label>Filter by Category:</label>
                <select id="categoryFilter">
                    <option value="all">All Categories</option>
                </select>
            </div>
            <div class="control-group">
                <label>Min Frequency:</label>
                <input type="range" id="frequencySlider" min="2" max="50" value="2">
                <span id="frequencyValue">2</span>
            </div>
            <div class="control-group">
                <button id="resetView">Reset View</button>
                <button id="exportData">Export Selection</button>
            </div>
        </div>

        <!-- Main Content Area -->
        <div id="main-content">
            <!-- Main Visualization Area -->
            <div id="visualization-container">
                <div id="network-view" class="view active">
                    <svg id="network-svg"></svg>
                </div>
                <div id="hierarchy-view" class="view">
                    <svg id="hierarchy-svg"></svg>
                </div>
                <div id="matrix-view" class="view">
                    <svg id="matrix-svg"></svg>
                </div>
            </div>

            <!-- Side Panel -->
            <div id="side-panel">
                <!-- Detail Panel -->
                <div id="detail-panel">
                    <h3>Concept Details</h3>
                    <div id="concept-info">
                        <p>Click on a concept to see details</p>
                    </div>
                    <div id="related-concepts">
                        <h4>Related Concepts</h4>
                        <ul id="related-list"></ul>
                    </div>
                    <div id="concept-insights">
                        <h4>Research Insights</h4>
                        <div id="insights-content"></div>
                    </div>
                    <div id="related-papers">
                        <h4>Related Papers</h4>
                        <div id="papers-list"></div>
                    </div>
                    <div id="concept-actions">
                        <button id="add-to-notes">Add to Research Notes</button>
                        <button id="copy-details">Copy Details</button>
                    </div>
                </div>

                <!-- Research Notes Section -->
                <div id="research-notes">
                    <h3>Research Notes</h3>
                    <textarea id="notes-input" placeholder="Add your research notes here..."></textarea>
                    <button id="save-notes">Save Notes</button>
                    <div id="saved-notes"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Paper Viewer Modal -->
    <div id="paper-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="paper-title">Paper Title</h2>
                <span class="close">&times;</span>
            </div>
            <div class="modal-body">
                <div id="paper-metadata"></div>
                <div id="paper-content"></div>
            </div>
        </div>
    </div>

    <script>
    // Global variables
    let data = null;
    let currentView = 'network';
    let selectedNodes = new Set();
    let notes = JSON.parse(localStorage.getItem('researchNotes') || '{}');

    // Load visualization data
    d3.json('data/visualization_data.json').then(function(loadedData) {
        data = loadedData;
        updateStats();
        initializeControls();
        renderVisualization();
    });

    // Update statistics in header
    function updateStats() {
        if (!data) return;
        
        // Update concept count
        const conceptCount = data.network.nodes.length;
        document.getElementById('concept-count').textContent = conceptCount;
        
        // Update paper count (count unique papers from sample_papers)
        const uniquePapers = new Set();
        data.network.nodes.forEach(node => {
            if (node.sample_papers) {
                node.sample_papers.forEach(paper => {
                    uniquePapers.add(paper.id);
                });
            }
        });
        document.getElementById('paper-count').textContent = uniquePapers.size;
        
        // Update category count
        const categoryCount = data.filters.categories.length;
        document.getElementById('category-count').textContent = categoryCount;
    }

    // Initialize controls
    function initializeControls() {
        // Populate category filter
        const categoryFilter = document.getElementById('categoryFilter');
        data.filters.categories.forEach(category => {
            const option = document.createElement('option');
            option.value = category;
            option.textContent = category.replace('_', ' ').charAt(0).toUpperCase() + category.slice(1);
            categoryFilter.appendChild(option);
        });

        // Event listeners
        document.getElementById('viewMode').addEventListener('change', function(e) {
            currentView = e.target.value;
            switchView();
        });

        document.getElementById('categoryFilter').addEventListener('change', renderVisualization);
        
        document.getElementById('frequencySlider').addEventListener('input', function(e) {
            document.getElementById('frequencyValue').textContent = e.target.value;
            renderVisualization();
        });

        document.getElementById('resetView').addEventListener('click', resetView);
        document.getElementById('exportData').addEventListener('click', exportData);
        document.getElementById('save-notes').addEventListener('click', saveNotes);
        
        // New action buttons
        document.getElementById('add-to-notes').addEventListener('click', addConceptToNotes);
        document.getElementById('copy-details').addEventListener('click', copyConceptDetails);
    }

    // Switch between views
    function switchView() {
        document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
        document.getElementById(currentView + '-view').classList.add('active');
        renderVisualization();
    }

    // Main rendering function
    function renderVisualization() {
        switch(currentView) {
            case 'network':
                renderNetworkGraph();
                break;
            case 'hierarchy':
                renderHierarchyTree();
                break;
            case 'matrix':
                renderCooccurrenceMatrix();
                break;
        }
    }

    // Network Graph Visualization
    function renderNetworkGraph() {
        const svg = d3.select('#network-svg');
        svg.selectAll('*').remove();

        const width = svg.node().getBoundingClientRect().width;
        const height = 600;
        svg.attr('width', width).attr('height', height);

        // Filter data based on controls
        const minFreq = parseInt(document.getElementById('frequencySlider').value);
        const category = document.getElementById('categoryFilter').value;
        
        const filteredNodes = data.network.nodes.filter(n => 
            n.frequency >= minFreq && 
            (category === 'all' || n.category === category)
        );
        
        const nodeIds = new Set(filteredNodes.map(n => n.id));
        const filteredEdges = data.network.edges.filter(e => 
            nodeIds.has(e.source) && nodeIds.has(e.target)
        );

        // Create force simulation
        const simulation = d3.forceSimulation(filteredNodes)
            .force('link', d3.forceLink(filteredEdges).id(d => d.id).distance(100))
            .force('charge', d3.forceManyBody().strength(-300))
            .force('center', d3.forceCenter(width / 2, height / 2))
            .force('collision', d3.forceCollide().radius(d => d.size + 5));

        // Create container
        const g = svg.append('g');

        // Add zoom behavior
        const zoom = d3.zoom()
            .scaleExtent([0.1, 4])
            .on('zoom', (event) => g.attr('transform', event.transform));
        
        svg.call(zoom);

        // Draw edges
        const link = g.selectAll('.link')
            .data(filteredEdges)
            .enter().append('line')
            .attr('class', 'link')
            .style('stroke', '#999')
            .style('stroke-opacity', 0.6)
            .style('stroke-width', d => Math.sqrt(d.weight));

        // Draw nodes
        const node = g.selectAll('.node')
            .data(filteredNodes)
            .enter().append('g')
            .attr('class', 'node')
            .call(d3.drag()
                .on('start', dragstarted)
                .on('drag', dragged)
                .on('end', dragended));

        // Node circles
        node.append('circle')
            .attr('r', d => d.size / 2)
            .style('fill', d => getCategoryColor(d.category))
            .style('stroke', '#fff')
            .style('stroke-width', 2)
            .on('click', (event, d) => selectNode(d))
            .on('mouseover', (event, d) => showTooltip(event, d))
            .on('mouseout', hideTooltip);

        // Node labels
        node.append('text')
            .text(d => d.name)
            .style('font-size', d => Math.min(d.size / 3, 12) + 'px')
            .attr('dx', d => d.size / 2 + 5)
            .attr('dy', 3);

        // Update positions on simulation tick
        simulation.on('tick', () => {
            link
                .attr('x1', d => d.source.x)
                .attr('y1', d => d.source.y)
                .attr('x2', d => d.target.x)
                .attr('y2', d => d.target.y);

            node.attr('transform', d => `translate(${d.x},${d.y})`);
        });

        // Drag functions
        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }
    }

    // Hierarchy Tree Visualization
    function renderHierarchyTree() {
        const svg = d3.select('#hierarchy-svg');
        svg.selectAll('*').remove();

        const width = svg.node().getBoundingClientRect().width;
        const height = 800;
        const margin = {top: 20, right: 90, bottom: 30, left: 90};

        svg.attr('width', width).attr('height', height);

        const g = svg.append('g')
            .attr('transform', `translate(${margin.left},${margin.top})`);

        // Create tree layout
        const treeLayout = d3.tree()
            .size([height - margin.top - margin.bottom, width - margin.left - margin.right]);

        // Create hierarchy
        const root = d3.hierarchy(data.hierarchy);
        treeLayout(root);

        // Draw links
        g.selectAll('.link')
            .data(root.links())
            .enter().append('path')
            .attr('class', 'link')
            .attr('d', d3.linkHorizontal()
                .x(d => d.y)
                .y(d => d.x))
            .style('fill', 'none')
            .style('stroke', '#ccc')
            .style('stroke-width', 2);

        // Draw nodes
        const node = g.selectAll('.node')
            .data(root.descendants())
            .enter().append('g')
            .attr('class', 'node')
            .attr('transform', d => `translate(${d.y},${d.x})`);

        node.append('circle')
            .attr('r', d => d.children ? 5 : 10)
            .style('fill', d => d.children ? '#555' : getCategoryColor(d.data.category))
            .on('click', (event, d) => {
                if (d.data.id !== undefined) {
                    selectNode(data.network.nodes.find(n => n.id === d.data.id));
                }
            });

        node.append('text')
            .attr('dy', 3)
            .attr('x', d => d.children ? -10 : 10)
            .style('text-anchor', d => d.children ? 'end' : 'start')
            .text(d => d.data.name)
            .style('font-size', '12px');
    }

    // Co-occurrence Matrix Visualization
    function renderCooccurrenceMatrix() {
        const svg = d3.select('#matrix-svg');
        svg.selectAll('*').remove();

        const width = 800;
        const height = 800;
        const margin = {top: 100, right: 10, bottom: 10, left: 100};

        svg.attr('width', width).attr('height', height);

        // Get top N concepts for matrix
        const topConcepts = data.network.nodes
            .sort((a, b) => b.frequency - a.frequency)
            .slice(0, 20);

        const conceptIds = topConcepts.map(c => c.id);
        const size = topConcepts.length;
        const cellSize = (width - margin.left - margin.right) / size;

        // Create matrix data
        const matrix = [];
        for (let i = 0; i < size; i++) {
            for (let j = 0; j < size; j++) {
                const edge = data.network.edges.find(e => 
                    (e.source === conceptIds[i] && e.target === conceptIds[j]) ||
                    (e.source === conceptIds[j] && e.target === conceptIds[i])
                );
                matrix.push({
                    x: j,
                    y: i,
                    value: edge ? edge.weight : (i === j ? topConcepts[i].frequency : 0)
                });
            }
        }

        const g = svg.append('g')
            .attr('transform', `translate(${margin.left},${margin.top})`);

        // Color scale
        const colorScale = d3.scaleSequential(d3.interpolateBlues)
            .domain([0, d3.max(matrix, d => d.value)]);

        // Draw cells
        g.selectAll('.cell')
            .data(matrix)
            .enter().append('rect')
            .attr('class', 'cell')
            .attr('x', d => d.x * cellSize)
            .attr('y', d => d.y * cellSize)
            .attr('width', cellSize - 2)
            .attr('height', cellSize - 2)
            .style('fill', d => d.value > 0 ? colorScale(d.value) : '#f0f0f0')
            .style('stroke', '#fff')
            .on('mouseover', (event, d) => {
                if (d.value > 0) {
                    showMatrixTooltip(event, d, topConcepts[d.y].name, topConcepts[d.x].name);
                }
            })
            .on('mouseout', hideTooltip);

        // Add labels
        g.selectAll('.row-label')
            .data(topConcepts)
            .enter().append('text')
            .attr('class', 'row-label')
            .attr('x', -5)
            .attr('y', (d, i) => i * cellSize + cellSize / 2)
            .attr('dy', 3)
            .style('text-anchor', 'end')
            .style('font-size', '10px')
            .text(d => d.name);

        g.selectAll('.col-label')
            .data(topConcepts)
            .enter().append('text')
            .attr('class', 'col-label')
            .attr('x', (d, i) => i * cellSize + cellSize / 2)
            .attr('y', -5)
            .attr('transform', (d, i) => `rotate(-45,${i * cellSize + cellSize / 2},-5)`)
            .style('text-anchor', 'start')
            .style('font-size', '10px')
            .text(d => d.name);
    }

    // Helper functions
    function getCategoryColor(category) {
        const colors = {
            'knowledge_graph': '#1f77b4',
            'hdm_specific': '#ff7f0e',
            'algorithms': '#2ca02c',
            'methodologies': '#d62728',
            'performance_metrics': '#9467bd',
            'architectures': '#8c564b',
            'frameworks_tools': '#e377c2',
            'data_integration': '#7f7f7f',
            'general': '#bcbd22',
            'temporal': '#17becf',
            'integration': '#aec7e8',
            'schema': '#ffbb78',
            'privacy': '#98df8a',
            'performance': '#ff9896'
        };
        return colors[category] || '#999';
    }

    function selectNode(node) {
        // Update selection
        if (selectedNodes.has(node.id)) {
            selectedNodes.delete(node.id);
        } else {
            selectedNodes.add(node.id);
        }

        // Update detail panel
        updateDetailPanel(node);

        // Highlight in visualization
        d3.selectAll('.node circle')
            .style('stroke-width', d => selectedNodes.has(d.id) ? 4 : 2)
            .style('stroke', d => selectedNodes.has(d.id) ? '#000' : '#fff');
    }

    function updateDetailPanel(node) {
        const info = document.getElementById('concept-info');
        info.innerHTML = `
            <h4 style="color: ${getCategoryColor(node.category)}; margin-bottom: 10px;">${node.name}</h4>
            <p><strong>Category:</strong> ${node.category.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}</p>
            <p><strong>Frequency:</strong> ${node.frequency} papers</p>
            <p><strong>Type:</strong> ${node.type}</p>
            <p><strong>Rank:</strong> #${node.id + 1} out of ${data.network.nodes.length} concepts</p>
        `;

        // Find related concepts
        const relatedList = document.getElementById('related-list');
        relatedList.innerHTML = '';
        
        const relatedEdges = data.network.edges.filter(e => 
            e.source === node.id || e.target === node.id
        );
        
        relatedEdges.forEach(edge => {
            const relatedId = edge.source === node.id ? edge.target : edge.source;
            const relatedNode = data.network.nodes.find(n => n.id === relatedId);
            if (relatedNode) {
                const li = document.createElement('li');
                li.innerHTML = `<strong>${relatedNode.name}</strong> 
                    <span style="color: #666;">(${relatedNode.category.replace(/_/g, ' ')}, 
                    strength: ${edge.weight})</span>`;
                li.style.cursor = 'pointer';
                li.onclick = () => selectNode(relatedNode);
                relatedList.appendChild(li);
            }
        });

        if (relatedEdges.length === 0) {
            relatedList.innerHTML = '<li style="color: #999;">No direct connections found</li>';
        }

        // Add research insights
        const insights = document.getElementById('insights-content');
        insights.innerHTML = generateInsights(node);

        // Add related papers
        updateRelatedPapers(node);

        // Update current selected node for actions
        window.currentSelectedNode = node;
    }

    function generateInsights(node) {
        let insights = '<ul>';
        
        // Category-specific insights
        const categoryInsights = {
            'knowledge_graph': 'Core PKG concept - fundamental to personal knowledge management systems',
            'hdm_specific': 'Human Digital Memory specific - critical for HDM system implementation',
            'algorithms': 'Algorithm/technique - computational approach for PKG/HDM systems',
            'methodologies': 'Research methodology - approach or framework for PKG development',
            'performance_metrics': 'Performance measure - used to evaluate PKG/HDM system effectiveness',
            'architectures': 'System architecture - structural design pattern for PKG systems',
            'frameworks_tools': 'Implementation tool - practical framework or database for PKG',
            'data_integration': 'Data integration approach - method for combining heterogeneous data'
        };
        
        if (categoryInsights[node.category]) {
            insights += `<li><strong>Category Insight:</strong> ${categoryInsights[node.category]}</li>`;
        }
        
        // Frequency-based insights
        if (node.frequency > 50) {
            insights += '<li><strong>High Frequency:</strong> This is a major concept in PKG research, appearing in 50+ papers</li>';
        } else if (node.frequency > 20) {
            insights += '<li><strong>Common Concept:</strong> Frequently discussed in PKG literature</li>';
        } else if (node.frequency < 5) {
            insights += '<li><strong>Emerging Concept:</strong> Relatively new or specialized area of research</li>';
        }
        
        // Temporal concepts
        if (node.name.toLowerCase().includes('temporal')) {
            insights += '<li><strong>Temporal Focus:</strong> Related to time-based aspects of knowledge graphs, crucial for HDM systems</li>';
        }
        
        // Integration concepts
        if (node.name.toLowerCase().includes('integration') || node.name.toLowerCase().includes('heterogeneous')) {
            insights += '<li><strong>Integration Focus:</strong> Important for combining diverse data sources in PKG systems</li>';
        }
        
        // Privacy concepts
        if (node.name.toLowerCase().includes('privacy') || node.name.toLowerCase().includes('preserving')) {
            insights += '<li><strong>Privacy Focus:</strong> Critical for personal data protection in PKG/HDM systems</li>';
        }
        
        insights += '</ul>';
        return insights;
    }

    function showTooltip(event, d) {
        const tooltip = d3.select('body').append('div')
            .attr('class', 'tooltip')
            .style('opacity', 0);

        tooltip.transition()
            .duration(200)
            .style('opacity', .9);
        
        tooltip.html(`<strong>${d.name}</strong><br/>
                     Category: ${d.category}<br/>
                     Frequency: ${d.frequency}`)
            .style('left', (event.pageX + 10) + 'px')
            .style('top', (event.pageY - 28) + 'px');
    }

    function showMatrixTooltip(event, d, row, col) {
        const tooltip = d3.select('body').append('div')
            .attr('class', 'tooltip')
            .style('opacity', 0);

        tooltip.transition()
            .duration(200)
            .style('opacity', .9);
        
        tooltip.html(`<strong>${row} ‚Üî ${col}</strong><br/>
                     Value: ${d.value}`)
            .style('left', (event.pageX + 10) + 'px')
            .style('top', (event.pageY - 28) + 'px');
    }

    function hideTooltip() {
        d3.selectAll('.tooltip').remove();
    }

    function resetView() {
        selectedNodes.clear();
        document.getElementById('categoryFilter').value = 'all';
        document.getElementById('frequencySlider').value = 2;
        document.getElementById('frequencyValue').textContent = '2';
        renderVisualization();
    }

    function exportData() {
        const exportObj = {
            selectedConcepts: Array.from(selectedNodes).map(id => {
                const node = data.network.nodes.find(n => n.id === id);
                return {
                    name: node.name,
                    category: node.category,
                    frequency: node.frequency
                };
            }),
            notes: notes,
            timestamp: new Date().toISOString()
        };

        const dataStr = JSON.stringify(exportObj, null, 2);
        const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
        
        const exportFileDefaultName = `research_export_${new Date().toISOString().slice(0,10)}.json`;
        
        const linkElement = document.createElement('a');
        linkElement.setAttribute('href', dataUri);
        linkElement.setAttribute('download', exportFileDefaultName);
        linkElement.click();
    }

    function saveNotes() {
        const noteText = document.getElementById('notes-input').value;
        if (noteText.trim()) {
            const timestamp = new Date().toISOString();
            notes[timestamp] = noteText;
            localStorage.setItem('researchNotes', JSON.stringify(notes));
            
            // Display saved note
            const savedDiv = document.getElementById('saved-notes');
            const noteDiv = document.createElement('div');
            noteDiv.className = 'saved-note';
            noteDiv.innerHTML = `<small>${new Date(timestamp).toLocaleString()}</small><p>${noteText}</p>`;
            savedDiv.insertBefore(noteDiv, savedDiv.firstChild);
            
            // Clear input
            document.getElementById('notes-input').value = '';
        }
    }

    // Load saved notes on startup
    window.addEventListener('load', () => {
        const savedDiv = document.getElementById('saved-notes');
        Object.entries(notes).reverse().forEach(([timestamp, text]) => {
            const noteDiv = document.createElement('div');
            noteDiv.className = 'saved-note';
            noteDiv.innerHTML = `<small>${new Date(timestamp).toLocaleString()}</small><p>${text}</p>`;
            savedDiv.appendChild(noteDiv);
        });
    });

    // New action functions
    function addConceptToNotes() {
        if (!window.currentSelectedNode) return;
        
        const node = window.currentSelectedNode;
        const noteText = `
Concept: ${node.name}
Category: ${node.category.replace(/_/g, ' ')}
Frequency: ${node.frequency} papers
Insights: ${generateInsights(node).replace(/<[^>]*>/g, ' ').trim()}
        `.trim();
        
        document.getElementById('notes-input').value = noteText + '\n\n' + document.getElementById('notes-input').value;
        document.getElementById('notes-input').focus();
    }

    function copyConceptDetails() {
        if (!window.currentSelectedNode) return;
        
        const node = window.currentSelectedNode;
        const relatedConcepts = data.network.edges
            .filter(e => e.source === node.id || e.target === node.id)
            .map(e => {
                const relatedId = e.source === node.id ? e.target : e.source;
                const relatedNode = data.network.nodes.find(n => n.id === relatedId);
                return relatedNode ? relatedNode.name : '';
            })
            .filter(name => name)
            .join(', ');
        
        const details = `
${node.name}
================
Category: ${node.category.replace(/_/g, ' ')}
Frequency: ${node.frequency} papers
Type: ${node.type}
Related Concepts: ${relatedConcepts || 'None'}

Insights:
${generateInsights(node).replace(/<[^>]*>/g, ' ').trim()}
        `.trim();
        
        navigator.clipboard.writeText(details).then(() => {
            // Show feedback
            const btn = document.getElementById('copy-details');
            const originalText = btn.textContent;
            btn.textContent = 'Copied!';
            btn.style.backgroundColor = '#27ae60';
            setTimeout(() => {
                btn.textContent = originalText;
                btn.style.backgroundColor = '';
            }, 2000);
        });
    }

    // Paper-related functions
    function updateRelatedPapers(node) {
        const papersList = document.getElementById('papers-list');
        papersList.innerHTML = '';
        
        if (node.sample_papers && node.sample_papers.length > 0) {
            const ul = document.createElement('ul');
            ul.style.listStyle = 'none';
            ul.style.padding = '0';
            
            node.sample_papers.forEach(paper => {
                const li = document.createElement('li');
                li.style.marginBottom = '15px';
                li.style.padding = '12px';
                li.style.backgroundColor = '#f8f9fa';
                li.style.borderRadius = '4px';
                li.style.borderLeft = '3px solid #3498db';
                li.style.cursor = 'pointer';
                li.style.transition = 'background-color 0.2s';
                
                li.innerHTML = `
                    <div style="font-weight: 500; color: #2c3e50; margin-bottom: 5px;">${paper.title || 'Untitled'}</div>
                    <div style="font-size: 13px; color: #666;">
                        ${paper.authors || 'Authors not available'} (${paper.year || 'Year unknown'})
                    </div>
                `;
                
                li.onmouseover = () => li.style.backgroundColor = '#e9ecef';
                li.onmouseout = () => li.style.backgroundColor = '#f8f9fa';
                li.onclick = () => loadPaper(paper.id || paper.cite_key);
                
                ul.appendChild(li);
            });
            
            papersList.appendChild(ul);
        } else {
            papersList.innerHTML = '<p style="color: #999; font-style: italic;">No sample papers available for this concept.</p>';
        }
    }

    function loadPaper(paperId) {
        if (!paperId) {
            alert('Paper ID not available');
            return;
        }
        
        // Show modal
        const modal = document.getElementById('paper-modal');
        modal.style.display = 'block';
        
        // Set loading state
        document.getElementById('paper-title').textContent = 'Loading Paper...';
        document.getElementById('paper-metadata').innerHTML = '';
        document.getElementById('paper-content').innerHTML = '<div style="text-align: center; padding: 40px;"><div class="loading-spinner"></div><p style="color: #666; margin-top: 20px;">Loading paper content...</p></div>';
        
        // Fetch paper markdown
        console.log('Attempting to fetch paper:', `/markdown_papers/${paperId}/paper.md`);
        fetch(`/markdown_papers/${paperId}/paper.md`)
            .then(response => {
                console.log('Paper fetch response:', response.status, response.statusText);
                if (!response.ok) throw new Error(`Paper not found: ${response.status} ${response.statusText}`);
                return response.text();
            })
            .then(markdown => {
                // Parse frontmatter
                const frontmatterMatch = markdown.match(/^---\n([\s\S]*?)\n---/);
                let metadata = {};
                let content = markdown;
                
                if (frontmatterMatch) {
                    // Parse YAML frontmatter (enhanced parsing)
                    const yamlContent = frontmatterMatch[1];
                    const lines = yamlContent.split('\n');
                    
                    let currentKey = null;
                    lines.forEach(line => {
                        // Handle key-value pairs
                        const match = line.match(/^(\w+):\s*(.*)$/);
                        if (match) {
                            currentKey = match[1];
                            const value = match[2].trim();
                            
                            // Remove quotes if present
                            if ((value.startsWith('"') && value.endsWith('"')) || 
                                (value.startsWith("'") && value.endsWith("'"))) {
                                metadata[currentKey] = value.slice(1, -1);
                            } else {
                                metadata[currentKey] = value;
                            }
                        } else if (currentKey && line.trim().startsWith('- ')) {
                            // Handle list items
                            if (!Array.isArray(metadata[currentKey])) {
                                metadata[currentKey] = [];
                            }
                            metadata[currentKey].push(line.trim().substring(2));
                        }
                    });
                    
                    // Remove frontmatter from content
                    content = markdown.substring(frontmatterMatch[0].length);
                }
                
                // Update modal
                document.getElementById('paper-title').textContent = metadata.title || 'Untitled Paper';
                
                document.getElementById('paper-metadata').innerHTML = `
                    <div style="margin-bottom: 20px; padding: 15px; background-color: #f8f9fa; border-radius: 4px;">
                        <p><strong>Authors:</strong> ${metadata.authors || 'Not available'}</p>
                        <p><strong>Year:</strong> ${metadata.year || 'Not available'}</p>
                        <p><strong>DOI:</strong> ${metadata.doi ? `<a href="https://doi.org/${metadata.doi}" target="_blank">${metadata.doi}</a>` : 'Not available'}</p>
                        <p><strong>URL:</strong> ${metadata.url ? `<a href="${metadata.url}" target="_blank">View Original</a>` : 'Not available'}</p>
                    </div>
                `;
                
                // Convert markdown to HTML using marked library
                const htmlContent = convertMarkdownToHtml(content, paperId);
                document.getElementById('paper-content').innerHTML = htmlContent;
            })
            .catch(error => {
                document.getElementById('paper-title').textContent = 'Error Loading Paper';
                document.getElementById('paper-content').innerHTML = `
                    <p style="color: red;">Failed to load paper: ${error.message}</p>
                    <p>Paper ID: ${paperId}</p>
                `;
            });
    }

    function convertMarkdownToHtml(markdown, paperId) {
        // Preprocess markdown to handle various citation formats
        console.log('Processing citations in markdown...');
        
        // Handle citation format [\[number\]]
        markdown = markdown.replace(/\[\\?\[(\d+)\\?\]\]/g, (match, num) => {
            console.log('Found citation:', match, '->', num);
            return `<sup><a href="#ref-${num}" style="color: #3498db; text-decoration: none;">[${num}]</a></sup>`;
        });
        
        // Handle standalone 'undefined' text that appears as citation placeholders
        // Only replace 'undefined' when it appears as a standalone word, not in compounds like "undefined-variable"
        markdown = markdown.replace(/\bundefined(?![-\w])/g, (match) => {
            console.log('Found undefined reference, replacing with [citation needed]');
            return '<span style="color: #e74c3c; font-style: italic;">[citation needed]</span>';
        });
        
        // Handle markdown links that might be citations
        markdown = markdown.replace(/\[(.*?)\]\(#page-(\d+)-(\d+)\)/g, (match, text, page, ref) => {
            console.log('Found page reference:', match);
            return `<sup><a href="#page-${page}-${ref}" style="color: #3498db; text-decoration: none;">[${text}]</a></sup>`;
        });
        
        // Create a new renderer instance
        const renderer = new marked.Renderer();
        
        // Override specific rendering methods
        renderer.image = function(href, title, text) {
            // Debug: log the original parameters
            console.log('Image renderer called with:', { href, title, text });
            
            // Handle case where href might be an object (marked.js compatibility issue)
            if (typeof href === 'object' && href !== null) {
                // If href is an object, try to extract the src property
                if (href.href) {
                    href = href.href;
                } else if (href.src) {
                    href = href.src;
                } else {
                    console.error('Image href is an object but no src/href property found:', href);
                    href = '';
                }
            }
            
            // Ensure href is a string
            href = String(href || '');
            console.log('Image href after processing:', href);
            
            // Check if it's a relative path
            if (href && !href.startsWith('http') && !href.startsWith('data:')) {
                // Adjust path to point to the correct location - use absolute path from server root
                const newHref = `/markdown_papers/${paperId}/${href}`;
                console.log('Image path transformation:', href, '->', newHref);
                href = newHref;
            }
            
            // Add responsive image styling with error handling and debugging
            return `<img src="${href}" alt="${text || ''}" title="${title || ''}" 
                    style="max-width: 100%; height: auto; display: block; margin: 20px auto;"
                    onload="console.log('Image loaded successfully: ${href}')"
                    onerror="console.error('Image failed to load: ${href}'); this.onerror=null; this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAwIiBoZWlnaHQ9IjMwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZjBmMGYwIi8+CiAgPHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSIxOCIgZmlsbD0iIzk5OSIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPkltYWdlIG5vdCBmb3VuZDwvdGV4dD4KPC9zdmc+'; this.alt='Image not found: ' + this.alt;">`;
        };
        
        renderer.table = function(header, body) {
            return `<div style="overflow-x: auto; margin: 20px 0;">
                <table style="border-collapse: collapse; width: 100%; min-width: 500px;">
                    <thead style="background-color: #f8f9fa;">${header}</thead>
                    <tbody>${body}</tbody>
                </table>
            </div>`;
        };
        
        renderer.tablerow = function(content) {
            return `<tr style="border-bottom: 1px solid #dee2e6;">${content}</tr>`;
        };
        
        renderer.tablecell = function(content, flags) {
            const type = flags.header ? 'th' : 'td';
            const align = flags.align ? `text-align: ${flags.align};` : '';
            const style = `padding: 12px; ${align} ${flags.header ? 'font-weight: bold;' : ''}`;
            return `<${type} style="${style}">${content}</${type}>`;
        };
        
        renderer.code = function(code, language) {
            return `<pre style="background-color: #f5f5f5; padding: 15px; border-radius: 4px; overflow-x: auto;"><code class="language-${language || 'text'}">${escapeHtml(code)}</code></pre>`;
        };
        
        renderer.link = function(href, title, text) {
            href = String(href || '');
            // Handle citation-style links that point to page anchors
            if (href.startsWith('#page-')) {
                return `<sup><a href="${href}" style="color: #3498db; text-decoration: none;">[${text}]</a></sup>`;
            }
            return `<a href="${href}" title="${title || ''}" target="_blank" style="color: #3498db;">${text}</a>`;
        };
        
        // Configure marked options with the custom renderer
        try {
            // Try the new API first (marked v4+)
            if (typeof marked.parse === 'function') {
                return marked.parse(markdown, {
                    renderer: renderer,
                    breaks: true,
                    gfm: true,
                    headerIds: true,
                    mangle: false,
                    pedantic: false,
                    sanitize: false,
                    smartLists: true,
                    smartypants: false
                });
            } else {
                // Fallback to old API
                marked.setOptions({
                    renderer: renderer,
                    breaks: true,
                    gfm: true,
                    headerIds: true,
                    mangle: false,
                    pedantic: false,
                    sanitize: false,
                    smartLists: true,
                    smartypants: false
                });
                return marked(markdown);
            }
        } catch (error) {
            console.error('Markdown parsing error:', error);
            // Fallback to basic rendering
            return `<pre>${escapeHtml(markdown)}</pre>`;
        }
    }
    
    function escapeHtml(text) {
        const map = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#039;'
        };
        return text.replace(/[&<>"']/g, m => map[m]);
    }

    // Modal close functionality
    document.addEventListener('DOMContentLoaded', function() {
        const modal = document.getElementById('paper-modal');
        const closeBtn = document.querySelector('.close');
        
        closeBtn.onclick = function() {
            modal.style.display = 'none';
        }
        
        window.onclick = function(event) {
            if (event.target == modal) {
                modal.style.display = 'none';
            }
        }
    });
    </script>
</body>
</html>